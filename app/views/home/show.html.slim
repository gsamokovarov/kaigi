section.center
  h2 Writing Debuggers in Plain <span class="red">Ruby</span>

section.center
  h2 üëã

section.center
  img.inline src=image_path("me.png")
  h2.fragment Genadi Samokovarov

section.center
  h2 „Ç≤„Éä„Éá„Ç£

section.center data-background="#000"
  h2.white „Ç≤„Éä„Éá„Ç£

section.center
  a(href="https://twitter.com/gsamokovarov") twitter.com/gsamokovarov

section.center
  a(href="https://github.com/gsamokovarov") github.com/gsamokovarov

section.center
  a href="https://receipt-bank.com"
    img.inline src="https://www.receipt-bank.com/assets/themes/receipt-bank-2014/images/rb-logo.svg"

section.center data-background="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9a/Flag_of_Bulgaria.svg/2000px-Flag_of_Bulgaria.svg.png"
  h2.white.shadow Bulgaria
  = copyright "Wikipedia", "https://en.wikipedia.org/wiki/Bulgaria"

section.center data-background="https://www.mapsland.com/maps/europe/bulgaria/large-location-map-of-bulgaria.jpg"
  h2.shadow Bulgaria
  = copyright "Wikipedia", "https://en.wikipedia.org/wiki/Bulgaria"

section.center data-background="#FCD846"
  a href="https://balkanruby.com"
    img.inline src=image_path("balkan.svg")
  p 17‚Äì18 May in Sofia, Bulgaria

section data-background="https://upload.wikimedia.org/wikipedia/commons/a/ad/AlexanderNevskyCathedral-Sofia-6.jpg"
  h2.white.shadow Sofia
  = copyright "Alexander Nevsky Cathedral", "https://en.wikipedia.org/wiki/Alexander_Nevsky_Cathedral%2C_Sofia"

section data-background="https://mir-s3-cdn-cf.behance.net/project_modules/fs/5ed17647510181.587cf8e0cafbe.jpg"
  h2.white.shadow –ù–î–ö
  = copyright "Dimitar Karanikolov", "http://www.dimitarkaranikolov.com/"

section data-background="https://mir-s3-cdn-cf.behance.net/project_modules/fs/cd6c3d47510181.587cf8e0cc19c.jpg"
  h2.white.shadow –ù–î–ö
  = copyright "Dimitar Karanikolov", "http://www.dimitarkaranikolov.com/"

section data-background="https://mir-s3-cdn-cf.behance.net/project_modules/fs/47ba5e47510181.587d0008bf99e.jpg"
  h2.white.shadow –ù–î–ö
  = copyright "Dimitar Karanikolov", "http://www.dimitarkaranikolov.com/"

section data-background="https://upload.wikimedia.org/wikipedia/commons/5/52/20140622_Buzludzha_016.jpg"
  h2.white.shadow Buzludzha
  = copyright "Buzludzha monument", "https://en.wikipedia.org/wiki/Buzludzha_monument"

section.center data-background-iframe="https://rubykaigi.org/2019/schedule"
  a(href="#" class="navigate-next") &gt;

section.center data-background="#000"
  h2.white.fragment Web Console

section.center data-background="#000"
  p.white A debugger that doesn't stop the world üåç

section.center data-background="#000"
  p.white Included by default since <span class="red">Rails 4.2</span>.

section.center
  pre(contenteditable=true): code.ruby
    '
      group :development do
        gem 'listen', '>= 3.0.5', '< 3.2'
        gem 'web-console'
        gem 'spring'
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      group :development do
        gem 'listen', '>= 3.0.5', '< 3.2'
        gem 'web-console' üëà
        gem 'spring'
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      group :development do
        gem 'listen', '>= 3.0.5', '< 3.2'
        gem 'web-console' üëå
        gem 'spring'
      end

section.center data-background-iframe="/error"
  a(href="#" class="navigate-next") &gt;

section.center data-background="#000"
  h2.white.fragment Writing <span class="red">Debuggers</span> in Plain Ruby!

section.center data-background="#F00" data-background-transition="fade"
  h2.white Debugger

section.center
  .fragment
    p A debugger (or debugging tool) is a computer program that is used to test and debug other programs.
    br
    a href="https://en.wikipedia.org/wiki/Debugger" https://en.wikipedia.org/wiki/Debugger

section.center
  h2 <span class="red">Debugging tool</span> <span class="fragment">ü§î</span>

section.center
  h2.fragment Kernel#puts <span class="fragment">üòÖ</span>

section.center
  h2 üëç

section.center
  a href="https://tenderlovemaking.com/2016/02/05/i-am-a-puts-debuggerer.html" I am a puts debuggerer

section.center data-background-iframe="https://tenderlovemaking.com/2016/02/05/i-am-a-puts-debuggerer.html"
  a(href="#" class="navigate-next") &gt;

section.center data-background-iframe="/console"
  a(href="#" class="navigate-next") &gt;

section.center
  h2 Binding#pry

section.center
  h2 Binding#irb

section.center data-background-iframe="/console"
  a(href="#" class="navigate-next") &gt;

section.center
  h2 üëå

section.center
  h2.fragment Byebug

section.center data-background-iframe="/console"
  a(href="#" class="navigate-next") &gt;

section.center data-background="#000"
  p.white Interrupts the debugged program.

section.center data-background="#000" data-background-transition="none"
  p.white Gives you control over its execution.

section.center data-background="#000" data-background-transition="none"
  p.white Let's you step-in(to) method calls.

section.center data-background="#000" data-background-transition="none"
  p.white Let's you step-out of method calls.

section.center data-background="#000" data-background-transition="none"
  p.white Let's you step-over of method calls.

section.center
  h2 üôå

section.center
  a href="https://tenderlovemaking.com/2016/02/05/i-am-a-puts-debuggerer.html" –ê Real Debugger! üòÇ

section.center data-background="#000"
  h2.fragment.white debug.rb

section.center
  h2.fragment ü§ö

section.center
  p Part of the standard library.

section.center
  a href="https://github.com/ruby/ruby/blob/3db12e8b236ac8f88db8eb4690d10e4a3b8dbcd4/lib/debug.rb" Part of the initial CVS to SVN import during January 1998 üïî

section.center
  p Written in plain Ruby!

section.center data-background="#000"
  p.white Written in plain Ruby!

section.center data-background="#000" data-background-transition="none"
  h2 üòÄ

section.center
  p Available everywhere.

section.center
  pre(contenteditable=true): code.ruby
    '
      require "debug"

section.center
  p GDB like user-interface.

section.center
  h2.fragment ‚òπÔ∏è

section.center
  p GDB like user-interface.

section.center
  p How do you invoke it twice in the same program run?

section.center
  p Last significant commit from 2013.

section.center
  p Uses <span class="red">Kernel#set_trace_func</span>

section.center data-background="#000"
  h2.fragment.white Kernel#set_trace_func

section.center
  p Invokes a proc on significant VM events.

section.center
  pre(contenteditable=true): code.ruby
    '
      set_trace_func -> event, file, line, id, binding {
        case event
        when "call"
          # A Ruby method is called.
        end
      }

section.center
  pre(contenteditable=true): code.ruby
    '
      set_trace_func -> event, file, line, id, binding {
        case event
        when "class"
          # A class or module is opened.
        end
      }

section.center
  pre(contenteditable=true): code.ruby
    '
      set_trace_func -> event, file, line, id, binding {
        case event
        when "end"
          # A class or module is closed.
        end
      }

section.center
  pre(contenteditable=true): code.ruby
    '
      set_trace_func -> event, file, line, id, binding {
        case event
        when "line"
          # A new line of code is executed.
        end
      }

section.center
  pre(contenteditable=true): code.ruby
    '
      set_trace_func -> event, file, line, id, binding {
        case event
        when "raised"
          # An exception is raised.
        end
      }

section.center
  pre(contenteditable=true): code.ruby
    '
      set_trace_func -> event, file, line, id, binding {
        case event
        when "return"
          # A Ruby method returns.
        end
      }

section.center
  p Soft deprecated in favour of the more modern TracePoint API.

section.center data-background="#000"
  p.white.fragment Clearly, it's possible to write debuggers in Ruby...

section.center data-background="#000" data-background-transition="none"
  p.white Why is <span class="red">Byebug</span> written in C?

section.center data-background="#000" data-background-transition="none"
  h2 ü§î

section.center data-background="#F00"
  h2.white Performance

section.center
  p <span class="red">Kernel#set_trace_func</span> is slow.

section.center
  p Invokes the proc for any event, even if you don't need to listen to it.

section.center data-background="#000"
  h2.white TracePoint API

section.center
  p Provides Object-Oriented API, similar to the functionality of <span class="red">Kernel#set_trace_func</span>.

section.center
  p Can listen only to specific events.

section.center
  p Can easily stop stracing the program.

section.center
  pre(contenteditable=true): code.ruby
    '
      TracePoint.trace(:line, :call, :return) do |trace|
        case trace.event
        when :call
          current.frames &lt;&lt; trace.binding
          current.depth += 1
        when :return
          current.frames.pop
          current.depth -= 1
        when :line
          next if current.depth.positive?

          trace.disable

          context = Context.new(*current.frames[0...-1], trace.binding)
          context.start
        end
      end

section.center data-background="#000"
  h3.white Events

section.center
  h3 line
  p execute code on a new line

section.center
  h3 class
  p start a class or module definition

section.center
  h3 end
  p finish a class or module definition

section.center
  h3 call
  p call a Ruby method

section.center
  h3 return
  p return from a Ruby method

section.center
  h3 c_call
  p call a C-language routine

section.center
  h3 c_return
  p return from a C-language routine

section.center
  h3 raise
  p raise an exception

section.center
  h3 b_call
  p event hook at block entry

section.center
  h3 b_return
  p event hook at block ending

section.center
  h3 thread_begin
  p event hook at thread beginning

section.center
  h3 thread_end
  p event hook at thread ending

section.center
  h3 fiber_switch
  p event hook at fiber switch

section.center
  h2 ü§î

section.center data-background="#000"
  h2.white ruby-debug

section.center
  p ruby-debug is a fast implementation of the standard debugger <span class="red">debug.rb</span>.

section.center
  p An old project, works for <span class="red">Ruby 1.8</span> and <span class="red">Ruby 1.9</span>.

section.center data-background="#FFF"
  h3 Ruby 1.8
  a href="https://github.com/ruby-debug/ruby-debug" ruby-debug

section.center data-background="#EEE"
  h3 Rewritten for Ruby 1.9
  a href="https://github.com/ruby-debug/ruby-debug-base19" ruby-debug-base-19

section.center data-background="#DDD"
  h3 Fork or ruby-debug-base for Ruby 2.x
  a href="https://github.com/cldwalker/debugger" debugger

section.center data-background="#CCC"
  h3 Unexported Ruby headers
  a href="https://github.com/cldwalker/debugger-ruby_core_source" debugger-ruby_core_source

section.center
  p The <span class="red">TracePoint API</span> solves most of the problems that sprouted the existence of <span class="red">ruby-debug</span>.

section.center
  p Writing debuggers back in the days was way more convoluted. üëµ

section.center data-background="#F00"
  h2.white Post-Mortem Debugging

section.center
  p Post-mortem debugging is debugging of the program after it has already crashed.

section.center data-background="#F00"
  h2.white Pry-open the VM stack frames

section.center
  p Kernel#caller

section.center
  p Kernel#caller_locations

section.center data-background="#000"
  h2.white Debug Inspector API

section.center
  p Let's you open the VM stack frames and build Binding objects for them.

section.center
  p CRuby specific and available only in C.

section.center
  pre(contenteditable=true): code.c
    '
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *);

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data);
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc);

section.center
  pre(contenteditable=true): code.c
    '
      static VALUE
      current_bindings_callback(const rb_debug_inspector_t *context, void *data)
      {
        VALUE locations = rb_debug_inspector_backtrace_locations(context);
        VALUE binding, bindings = rb_ary_new();
        long i, length = RARRAY_LEN(locations);

        for (i = 0; i < length; i++) {
          binding = rb_debug_inspector_frame_binding_get(context, i);

          if (!NIL_P(binding)) {
            rb_ary_push(bindings, binding);
          }
        }

        return bindings;
      }

section.center
  pre(contenteditable=true): code.c
    '
      static VALUE
      current_bindings(void)
      {
        return rb_debug_inspector_open(current_bindings_callback, NULL);
      }

section.center data-background="#000"
  h2.white High-level APIs

section.center
  p <span class="red">TracePoint</span> is a high-level API.

section.center
  p <span class="red">Debug Inspector</span>, although in C, is a high-level API.

section.center
  h2 ü§î

section.center
  p Why not make it official?

section.center data-background="#00F"
  h4.white DebugInspector#open

section.center
  a href="https://github.com/banister/debug_inspector" debug_inspector
  = copyright "@banister", "https://github.com/banister/debug_inspector"

section.center
  pre(contenteditable=true): code.ruby
    '
      require 'debug_inspector'

      RubyVM::DebugInspector.open { |dc|
        locs = dc.backtrace_locations

        # you can get depth of stack frame with `locs.size'
        locs.size.times do |i|
          # binding of i-th caller frame (returns a Binding object or nil)
          p dc.frame_binding(i)

          # iseq of i-th caller frame (returns a RubyVM::InstructionSequence object or nil)
          p dc.frame_iseq(i)

          # class of i-th caller frame
          p dc.frame_class(i)
        end
      }
  = copyright "debug_inspector", "https://github.com/banister/debug_inspector"

section.center
  pre(contenteditable=true): code.c
    '
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *);

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data);
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc);
  = copyright "debug_inspector", "https://github.com/banister/debug_inspector"

section.center
  pre(contenteditable=true): code.ruby
    '
      require 'debug_inspector'

      DebugInspector.open do |context|
        locations = context.backtrace_locations

        locations.size.times do |i|
          # binding of i-th caller frame (returns a Binding object or nil)
          p context.frame_binding(i)

          # iseq of i-th caller frame (returns a RubyVM::InstructionSequence object or nil)
          p context.frame_iseq(i)

          # class of i-th caller frame
          p context.frame_class(i)
        end
      end

section.center
  h2 üëç

section.center
  h2 üëé

section.center data-background-iframe="/error"
  a(href="#" class="navigate-next") &gt;

section.center data-background="#00F"
  h4.white Thread::Backtrace::Location#binding

section.center
  p A suggestion by <a href="https://twitter.com/tom_enebo">@tom_enebo</a> at Kaigi 2018.

section.center
  pre(contenteditable=true): code.ruby
    '
      backtrace = caller_locations
      if trace = backtrace[3]
        # C frames cannot build binding.
        trace.binding
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      backtrace = caller_locations
      if trace = backtrace[3]
        # Have optimizing VM like JRuby or TruffleRuby?
        trace.binding
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      backtrace = caller_locations
      if trace = backtrace[3]
        # Return nil for for such frames.
        trace.binding
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      backtrace = caller_locations
      if trace = backtrace[3]
        # Produce a warning, if you wish.
        trace.binding
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      backtrace = caller_locations
      if trace = backtrace[3]
        # No need for trace <=> binding mapping!
        trace.binding
      end

section.center
  h2 üëç

section.center data-background="#000"
  p.white The APIs can be implemented by the VM maintainers.

section.center data-background="#000" data-background-transition="none"
  p.white The debuggers can become more or less UX work that is portable across VMs.

section.center data-background="#000" data-background-transition="none"
  h2.white Pros & Cons

section.center
  h2 Cons
  ul
    li.fragment Performance!
    li.fragment Dangerous operations?

section.center
  h2 Pros
  ul
    li.fragment Portable debugging tools!
    li.fragment Adoption!

section.center data-background="#0F0"
  h2 Case Study

section.center
  img.inline src="https://upload.wikimedia.org/wikipedia/commons/f/f8/Python_logo_and_wordmark.svg"

section.center
  a href="https://docs.python.org/3/library/sys.html?highlight=sys%20_getframe#sys._getframe" sys._getframe

section.center
  h2 üòÖ

section.center data-background-iframe="https://docs.python.org/3/library/sys.html?highlight=sys%20_getframe#sys._getframe"
  a(href="#" class="navigate-next") &gt;

section.center
  a href="https://docs.python.org/3/reference/datamodel.html#frame-objects" Frame Objects

section.center data-background-iframe="https://docs.python.org/3/reference/datamodel.html#frame-objects"
  a(href="#" class="navigate-next") &gt;

section.center
  a href="https://github.com/banister/binding_of_caller" binding_of_caller
  = copyright "@banister", "https://github.com/banister/debug_inspector"

section.center data-background="#000"
  h2.white Boogah

section.center
  p Proof of concept debugger written using the <span class="red">TracePoint API</span>.

section.center
  p Not production ready, purely for educational purposes.

section.center
  pre(contenteditable=true): code.ruby
    '
      class Binding
        def boogah
          context = Boogah::Context.new(self)
          context.start
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      module Boogah::Context
        attr_accessor :frames, :depth

        def initialize(*frames, depth: 0)
          @frames,@depth = frames, depth
          @repl = REPL.new(current_binding)
        end

        def start; @repl.start(self); end
        def stop; @repl.stop; end

        private

        def current_binding
          @frames[@depth - 1]
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      module Boogah::REPL
        def initialize(binding)
          IRB.setup(caller_locations.first.path, argv: [])

          @binding = binding
          @workspace = IRB::WorkSpace.new(@binding)
          @irb = IRB::Irb.new(@workspace)
        end

        def start(context)
          @binding.receiver.singleton_class.prepend(Boogah::Commands.new(context))
          @irb.run(IRB.conf)
        end

        def stop
          @irb.context.exit
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      module Boogah::REPL
        def initialize(binding)
          IRB.setup(caller_locations.first.path, argv: [])

          @binding = binding
          @workspace = IRB::WorkSpace.new(@binding)
          @irb = IRB::Irb.new(@workspace)
        end

        def start(context)
          @binding.receiver.singleton_class.prepend(Boogah::Commands.new(context))
          @irb.run(IRB.conf)
        end

        def stop
          @irb.context.exit
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      module Boogah::Commands < Module
        def initialize(current)
          Dir.each_child current_directory.join("commands") do |cmd|
            require_command { "commands/\#{cmd}" }
          end
        end

        def command(name, short: nil, &block)
          define_method(name, &block)
          alias_method short, name if short
        end

        private

        def require_command(&block)
          filename = block.call
          filename += ".rb" unless filename.end_with?(".rb")

          block.binding.eval(current_directory.join(filename).read)
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      command :next, short: :n do
        TracePoint.trace(:line, :call, :return) do |trace|
          case trace.event
          when :call
            current.frames << trace.binding
            current.depth += 1
          when :return
            current.frames.pop
            current.depth -= 1
          when :line
            next if current.depth.positive?

            trace.disable

            context = Context.new(*current.frames[0...-1], trace.binding)
            context.start
          end
        end

        current.stop
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      command :step, short: :s do
        TracePoint.trace(:call, :return, :line) do |trace|
          case trace.event
          when :call
            trace.disable

            context = Context.new(*current.frames, trace.binding)
            context.start
          when :return
            current.frames.pop
            current.depth -= 1
          when :line
            next if current.depth.positive?

            trace.disable

            context = Context.new(*current.frames[0...-1], trace.binding)
            context.start
          end
        end

        current.stop
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      command :up, short: :u do
        TracePoint.trace do |trace|
          trace.disable

          context = Context.new(*current.frames, depth: current.depth - 1)
          context.start
        end

        current.stop
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      command :down, short: :d do
        TracePoint.trace do |trace|
          trace.disable

          context = Context.new(*current.frames, depth: current.depth + 1)
          context.start
        end

        current.stop
      end

section.center
  a href="https://github.com/gsamokovarov/boogah" gsamokovarov/boogah

section.center data-background-iframe="/console"
  a(href="#" class="navigate-next") &gt;

section.center data-background="#000"
  h2.white.fragment TL;DR

section.center data-background="#000" data-background-transition="none"
  p.white Writing debuggers may seem daunting, but we have great APIs to do so.

section.center data-background="#000" data-background-transition="none"
  p.white With a little bit of effort, we can remove the need of lower-level code altogether.

section.center data-background="#000" data-background-transition="none"
  p.white Debuggers can be mostly UX work.

section.center data-background="#000" data-background-transition="none"
  p.white Debuggers can be portable.

section.center data-background="#000" data-background-transition="none"
  h2.white.fragment Thank you!

section.center data-background="#000" data-background-transition="none"
  h2.white üôá‚Äç‚ôÇÔ∏è
