section.center data-background="#000"
  h2.white Writing Debuggers in Plain <span class="red">Ruby</span>

section.center
  h2 ðŸ‘‹

section.center
  img.inline src=image_path("me.png")
  h2.fragment Genadi Samokovarov

section.center
  h2 ã‚²ãƒŠãƒ‡ã‚£

section.center data-background="#000"
  h2.white ã‚²ãƒŠãƒ‡ã‚£

section.center
  a(href="https://twitter.com/gsamokovarov") twitter.com/gsamokovarov

section.center
  a(href="https://github.com/gsamokovarov") github.com/gsamokovarov

section.center
  a href="https://receipt-bank.com"
    img.inline src="https://www.receipt-bank.com/assets/themes/receipt-bank-2014/images/rb-logo.svg"

section.center data-background="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9a/Flag_of_Bulgaria.svg/2000px-Flag_of_Bulgaria.svg.png"
  h2.white.shadow Bulgaria
  = copyright "Wikipedia", "https://en.wikipedia.org/wiki/Bulgaria"

section.center data-background="https://www.mapsland.com/maps/europe/bulgaria/large-location-map-of-bulgaria.jpg"
  h2.shadow Bulgaria
  = copyright "Wikipedia", "https://en.wikipedia.org/wiki/Bulgaria"

section data-background="https://cdn2.wanderlust.co.uk/media/2637/articles-public-mineral-baths-sofia-bulgaria-dreamstime.jpg"
  h2.white.shadow Sofia
  = copyright "Wanderlust", "https://www.wanderlust.co.uk/content/short-break-guide-to-sofia-bulgaria/"

section data-background="https://cdn2.wanderlust.co.uk/media/2632/magazine-1335.jpg"
  h2.white.shadow Sofia
  = copyright "Wanderlust", "https://www.wanderlust.co.uk/content/short-break-guide-to-sofia-bulgaria/"

section data-background="https://cdn2.wanderlust.co.uk/media/2633/magazine-2328.jpg"
  h2.white.shadow Sofia
  = copyright "Wanderlust", "https://www.wanderlust.co.uk/content/short-break-guide-to-sofia-bulgaria/"

section.center data-background="#FCD846"
  a href="https://balkanruby.com"
    img.inline src=image_path("balkan.svg")
  p 17â€“18 May in Sofia, Bulgaria

section.center data-background="#000"
  h2.white.fragment Writing <span class="red">Debuggers</span> in Plain Ruby!

section.center data-background="#F00" data-background-transition="fade"
  h2.white Debugger

section.center
  .fragment
    p A debugger (or debugging tool) is a computer program that is used to test and debug other programs.
    br
    a href="https://en.wikipedia.org/wiki/Debugger" https://en.wikipedia.org/wiki/Debugger

section.center
  h2 <span class="red">Debugging tool</span> <span class="fragment">ðŸ¤”</span>

section.center
  h2.fragment Kernel#puts <span class="fragment">ðŸ˜…</span>

section.center
  h2 ðŸ‘

section.center
  a href="https://tenderlovemaking.com/2016/02/05/i-am-a-puts-debuggerer.html" I am a puts debuggerer

section.center data-background-iframe="https://tenderlovemaking.com/2016/02/05/i-am-a-puts-debuggerer.html"
  a(href="#" class="navigate-next") &gt;

section.center
  h2 Binding#pry

section.center
  h2 Binding#irb

section.center data-background-iframe="/console"
  h2 Binding#irb
  a(href="#" class="navigate-next") &gt;

section.center
  h2 ðŸ‘Œ

section.center
  h2.fragment Byebug

section.center data-background="#000"
  p.white Interrupts the debugged program.

section.center data-background="#000" data-background-transition="none"
  p.white Gives you control over its execution.

section.center data-background="#000" data-background-transition="none"
  p.white Let's you step-in(to) method calls.

section.center data-background="#000" data-background-transition="none"
  p.white Let's you step-out of method calls.

section.center data-background="#000" data-background-transition="none"
  p.white Let's you step-over of method calls.

section.center
  h2 ðŸ™Œ

section.center
  a href="https://tenderlovemaking.com/2016/02/05/i-am-a-puts-debuggerer.html" Ð Real Debugger! ðŸ˜‚

section.center data-background="#000"
  h2.fragment.white debug.rb

section.center
  h2.fragment ðŸ¤š

section.center
  p Part of the standard library.

section.center
  a href="https://github.com/ruby/ruby/blob/3db12e8b236ac8f88db8eb4690d10e4a3b8dbcd4/lib/debug.rb" Part of the initial CVS to SVN import during January 1998 ðŸ•”

section.center data-background-iframe="https://github.com/ruby/ruby/blob/3db12e8b236ac8f88db8eb4690d10e4a3b8dbcd4/lib/debug.rb"
  a(href="#" class="navigate-next") &gt;

section.center
  p Written in plain Ruby!

section.center data-background="#000"
  p.white Written in plain Ruby!

section.center data-background="#000" data-background-transition="none"
  h2 ðŸ˜€

section data-background="https://gifimage.net/wp-content/uploads/2017/08/thats-all-folks-gif-2.gif" data-background-transition="none"

section.center data-background="#000" data-background-transition="none"
  p.white Fact!

section.center data-background="#000" data-background-transition="none"
  h2 ðŸ‘

section.center
  h2.fragment ðŸ˜€

section.center
  p Available everywhere.

section.center
  pre(contenteditable=true): code.ruby
    '
      require "debug"

section.center
  p GDB like user-interface.

section.center
  h2.fragment â˜¹ï¸

section.center
  p GDB like user-interface.

section.center
  p How do you invoke it twice in the same program run?

section.center
  p Last significant commit from 2013.

section.center
  p Uses Kernel#set_trace_func

section.center data-background="#000"
  h2.fragment.white Kernel#set_trace_func

section.center
  p Invokes a proc on significant VM events.

section.center
  pre(contenteditable=true): code.ruby
    '
      set_trace_func -> event, file, line, id, binding {
        case event
        when "call"
          # A Ruby method is called.
        end
      }

section.center
  pre(contenteditable=true): code.ruby
    '
      set_trace_func -> event, file, line, id, binding {
        case event
        when "class"
          # A class or module is opened.
        end
      }

section.center
  pre(contenteditable=true): code.ruby
    '
      set_trace_func -> event, file, line, id, binding {
        case event
        when "end"
          # A class or module is closed.
        end
      }

section.center
  pre(contenteditable=true): code.ruby
    '
      set_trace_func -> event, file, line, id, binding {
        case event
        when "line"
          # A new line of code is executed.
        end
      }

section.center
  pre(contenteditable=true): code.ruby
    '
      set_trace_func -> event, file, line, id, binding {
        case event
        when "raised"
          # An exception is raised.
        end
      }

section.center
  pre(contenteditable=true): code.ruby
    '
      set_trace_func -> event, file, line, id, binding {
        case event
        when "return"
          # A Ruby method returns.
        end
      }

section.center
  p Soft deprecated in favour of the more modern TracePoint API.

section.center data-background="#000"
  p.white.fragment Clearly, it's possible to write debuggers in Ruby...

section.center data-background="#000" data-background-transition="none"
  p.white Why is <span class="red">Byebug</span> written in C?

section.center data-background="#000" data-background-transition="none"
  h2 ðŸ¤”

section.center data-background="#F00"
  h2.white Performance

section.center
  p <span class="red">Kernel#set_trace_func is slow</span>.

section.center
  p Invokes the proc for any event, even if you don't need to listen to it.

section.center data-background="#000"
  h2.white TracePoint API

section.center
  p Provides Object-Oriented API, similar to the functionality of <span class="red">Kernel#set_trace_func</span>.

section.center
  p Can listen only to specific events.

section.center
  p Can easily stop stracing the program.

section.center
  pre(contenteditable=true): code.ruby
    '
      TracePoint.trace(:line, :call, :return) do |trace|
        case trace.event
        when :call
          current.frames &lt;&lt; trace.binding
          current.depth += 1
        when :return
          current.frames.pop
          current.depth -= 1
        when :line
          next if current.depth.positive?

          trace.disable

          context = Context.new(*current.frames[0...-1], trace.binding)
          context.start
        end
      end

section.center data-background="#000"
  h3.white Events

section.center
  h3 line
  p execute code on a new line

section.center
  h3 class
  p start a class or module definition

section.center
  h3 end
  p finish a class or module definition

section.center
  h3 call
  p call a Ruby method

section.center
  h3 return
  p return from a Ruby method

section.center
  h3 c_call
  p call a C-language routine

section.center
  h3 c_return
  p return from a C-language routine

section.center
  h3 raise
  p raise an exception

section.center
  h3 b_call
  p event hook at block entry

section.center
  h3 b_return
  p event hook at block ending

section.center
  h3 thread_begin
  p event hook at thread beginning

section.center
  h3 thread_end
  p event hook at thread ending

section.center
  h3 fiber_switch
  p event hook at fiber switch

section.center data-background="#F00"
  h2.white Post-Mortem Debugging

section.center
  p Post-mortem debugging is debugging of the program after it has already crashed.

section.center data-background="#F00"
  h2.white Pry-open the VM stack frames

section.center
  p Kernel#caller

section.center
  p Kernel#caller_locations

section.center data-background="#000"
  h2.white Debug Inspector API

section.center
  p Let's you open the VM stack frames and build Binding objects for them.

section.center
  p CRuby specific and available only in C.

section.center
  p High-level API.

section.center
  pre(contenteditable=true): code.c
    '
      /* debug inspector APIs */
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *);

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data);
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc);

section.center
  pre(contenteditable=true): code.c
    '
      /* debug inspector APIs */
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *);

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data);
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc);

section.center
  pre(contenteditable=true): code.c
    '
      /* debug inspector APIs */
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *);

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data); ðŸ‘ˆ
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc);

section.center
  pre(contenteditable=true): code.c
    '
      /* debug inspector APIs */
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *); ðŸ‘ˆ

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data);
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc);

section.center
  pre(contenteditable=true): code.c
    '
      /* debug inspector APIs */
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *);

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data);
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc); ðŸ‘ˆ

section.center
  pre(contenteditable=true): code.c
    '
      /* debug inspector APIs */
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *);

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data);
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index); ðŸ‘ˆ
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc);

section.center
  pre(contenteditable=true): code.c
    '
      /* debug inspector APIs */
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *);

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data);
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index); ðŸ‘ˆ
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc);

section.center
  pre(contenteditable=true): code.c
    '
      /* debug inspector APIs */
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *);

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data);
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index); ðŸ‘ˆ
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc);

section.center
  pre(contenteditable=true): code.c
    '
      /* debug inspector APIs */
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *);

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data);
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index); ðŸ‘ˆ
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc);
